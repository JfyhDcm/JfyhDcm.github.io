<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPP-STL</title>
    <url>/2021/06/18/CPP-STL/</url>
    <content><![CDATA[<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><a href="https://blog.csdn.net/wkq0825/article/details/82255984">基本语法</a></p>
<p><a href="https://www.cnblogs.com/tyty-Somnuspoppy/p/9361821.html">双层vector</a></p>
]]></content>
  </entry>
  <entry>
    <title>WordEmbedding1:BagofWords</title>
    <url>/2021/10/24/WordEmbedding1:BagofWords/</url>
    <content><![CDATA[<ul>
<li>==<strong>基于one-hot、tf-idf、textrank等的bag-of-words；</strong>==</li>
<li><strong>主题模型：LSA（SVD）、pLSA、LDA；</strong></li>
<li><strong>基于词向量的固定表征：word2vec、fastText、glove</strong></li>
<li><strong>基于词向量的动态表征：elmo、GPT、bert</strong></li>
</ul>
<h1 id="Bag-of-words"><a href="#Bag-of-words" class="headerlink" title="Bag-of-words"></a>Bag-of-words</h1><h2 id="TF-IFD算法"><a href="#TF-IFD算法" class="headerlink" title="TF-IFD算法"></a>TF-IFD算法</h2><p>TF-IDF（term frequency–inverse document frequency，词频-逆向文件频率）是一种用于信息检索（information retrieval）与文本挖掘（text mining）的常用加权技术。</p>
<p>   TF-IDF是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。字词的重要性随着它在**==文件==<strong>中出现的次数成正比增加，但同时会随着它在</strong>==语料库==**中出现的频率成反比下降。</p>
<p>   TF-IDF的主要思想是：如果某个单词在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。</p>
<p>TF词频 公式：<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvq88r14w2j605l0203yc02.jpg" alt="img"></p>
<p>即：<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvq89qvhplj609m01wt8p02.jpg" alt="img"></p>
<p>IDF 逆向文件频率：<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvq8a9n46bj607w02a0sm02.jpg" alt="img"></p>
<p>即：<img src="https://img-blog.csdn.net/20180807191126207?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzaWFsZWVfYmlyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>TF-IDF为：<img src="https://img-blog.csdn.net/201808071912424?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzaWFsZWVfYmlyZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<ul>
<li>优点：1. 可用某篇文章中出现次数多但在其他文章中出现次数少的词来作为该篇文章的特征词。2. 使罕见的单词更加突出并且有效地忽略了常用单词 3. 易于理解</li>
<li>缺点：1. 因为是词袋模型，所以没有考虑词的位置信息，但词的位置是有一定含义的。2. 并不能反映单词的重要程度和特征词的分布情况。</li>
</ul>
<h2 id="TextRank"><a href="#TextRank" class="headerlink" title="TextRank"></a>TextRank</h2><h3 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h3><ul>
<li>如果一个网页被很多其他网页链接到的话说明这个网页比较重要，也就是PageRank值会相对较高</li>
<li>如果一个PageRank值很高的网页链接到一个其他的网页，那么被链接到的网页的PageRank值会相应地因此而提高</li>
</ul>
<img src="https://raw.githubusercontent.com/evilKing/storage_image/master/page_rank1.png" alt="img" style="zoom:50%;" />

<p>PageRank算法预先给每个网页一个 PR值（下面用 PR值指代 PageRank值），由于 PR值物理意义上为一个网页被访问概率，所以一般是1/N ，其中 N 为网页总数。另外，一般情况下，所有网页的 PR值的总和为 1。如果不为 1的话也不是不行，最后算出来的不同网页之间 PR值的大小关系仍然是正确的，只是不能直接地反映概率了。</p>
<p><img src="https://raw.githubusercontent.com/evilKing/storage_image/master/page_rank.jpg" alt="img"></p>
<p>互联网中的众多网页可以看作一个有向图。预先给定 PR值后，通过下面的算法不断迭代，直至达到平稳分布为止。这时 A 的 PR值就可以表示为 :<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqf8d903cj60de02ewee02.jpg" alt="image-20211024111841444" style="zoom:50%;" />然而图中除了 C 之外，B 和 D 都不止有一条出链，所以上面的计算式并不准确。想象一个用户现在浏览 B 网页，那么下一步他打开 A 网页还是 D网页在统计上应该是相同概率的。所以 A 的 PR值应该表述为 :<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqf8can5wj60fe03qt8n02.jpg" alt="image-20211024112044985" style="zoom:50%;" /></p>
<p>互联网中不乏一些没有出链的网页，如图:</p>
<p><img src="https://raw.githubusercontent.com/evilKing/storage_image/master/page_rank3.jpg" alt="img"></p>
<p>图中的 C 网页没有出链，对其他网页没有 PR值的贡献，我们不喜欢这种自私的网页（其实是为了满足 Markov 链的收敛性），于是设定其对所有的网页（包括它自己）都有出链，则此图中A的PR值（设定C也连到了A）可表示为：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqf8g2hmmj60e604gwef02.jpg" alt="image-20211024112321973" style="zoom:50%;" />

<p>然而我们再考虑一种情况：互联网中一个网页只有对自己的出链，或者几个网页的出链形成一个循环圈。那么在不断地迭代过程中，这一个或几个网页的PR值将只增不减，显然不合理。如下图中的 C 网页就是刚刚说的只有对自己的出链的网页：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqf8e4r2zj60hu0fc3yx02.jpg" alt="image-20211024112609155" style="zoom:50%;" />

<p>为了解决这个问题，我们想象一个随机浏览网页的人，当他到达 C 网页后，显然不会傻傻地一直被 C 网页的小把戏困住。我们假定他有一个确定的概率会输入网址直接跳转到一个随机的网页，并且跳转到每个网页的概率是一样的。于是则此图中 A 的 PR值可表示为：<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqf8f4rwvj60hy04wjrc02.jpg" alt="image-20211024112634051" style="zoom:50%;" />这里的α是阻尼系数，google系统选用0.85，表示用户愿意按照网页跳转指示浏览网页的概率。</p>
<p>总结一下：<img src="https://pic1.zhimg.com/80/v2-0d6c3c27eeee373e89b02e57630df6e4_1440w.jpg" alt="img"></p>
<h3 id="TextRank-1"><a href="#TextRank-1" class="headerlink" title="TextRank"></a>TextRank</h3><p>网页之间的链接关系可以用图表示，那么怎么把一个句子（可以看作词的序列）构建成图呢？TextRank将某一个词与其前面的N个词、以及后面的N个词均具有图相邻关系（类似于N-gram语法模型）。</p>
<p>具体实现：设置一个长度为N的滑动窗口，所有在这个窗口之内的词都视作词结点的相邻结点；则TextRank构建的词图为无向图。下图给出了由一个文档构建的词图（去掉了停用词并按词性做了筛选）：</p>
<img src="https://pic2.zhimg.com/80/v2-45e33818add08141d4deea618d1bd6c9_1440w.jpg" alt="img" style="zoom: 50%;" />

<p>考虑到不同词对可能有不同的共现（co-occurrence），TextRank将共现作为无向图边的权值。那么，TextRank的迭代计算公式如下：<img src="https://pic2.zhimg.com/80/v2-04b2c330a7f471e8b93f78963e6c1619_1440w.jpg" alt="img"></p>
<p>d为阻尼系数；$w_{ij}$为权重，用来表示两个节点间边连接的不同重要程度。</p>
<p>==最后求得各节点权重。==</p>
<h3 id="TextRank用户关键词提取"><a href="#TextRank用户关键词提取" class="headerlink" title="TextRank用户关键词提取"></a>TextRank用户关键词提取</h3><p>1)把给定的文本T按照完整句子进行分割，即</p>
<p><img src="https://pic2.zhimg.com/80/v2-8c209ef93e503864960a934bc6a5b389_1440w.jpg" alt="img"></p>
<p>2)对于每个句子Si属于T，进行分词和词性标注处理，并过滤掉停用词，只保留指定词性的单词，如名词、动词、形容词，即</p>
<p><img src="https://pic3.zhimg.com/80/v2-d9ab45963e0e227ebc98e871802fa31a_1440w.jpg" alt="img"></p>
<p>，其中 ti,j 是保留后的候选关键词。</p>
<p>　　3)构建候选关键词图G = (V,E)，其中V为节点集，由（2）生成的候选关键词组成，然后采用共现关系（co-occurrence）构造任两点之间的边，两个节点之间存在边仅当它们对应的词汇在长度为K的窗口中共现，K表示窗口大小，即最多共现K个单词。</p>
<p>　　4)根据上面公式，迭代传播==各节点的权重==，直至收敛。</p>
<p>　　5)对节点权重进行倒序排序，从而得到最重要的T个单词，作为候选关键词。</p>
<p>　　6)由5得到最重要的T个单词，在原始文本中进行标记，若形成相邻词组，则组合成多词关键词。</p>
<p><strong>补充：提取关键词短语</strong>：提取关键词短语的方法基于关键词提取，可以简单认为：如果提取出的若干关键词在文本中相邻，那么构成一个被提取的关键短语。</p>
<p><strong>停用词：</strong>是指在信息检索中，为节省存储空间和提高搜索效率，在处理自然语言数据（或文本）之前或之后会自动过滤掉某些字或词，这些字或词即被称为Stop Words（停用词）。这些停用词都是人工输入、非自动化生成的，生成后的停用词会形成一个停用词表。但是，并没有一个明确的停用词表能够适用于所有的工具。甚至有一些工具是明确地避免使用停用词来支持短语搜索的。</p>
<h3 id="TextRank生成文章摘要"><a href="#TextRank生成文章摘要" class="headerlink" title="TextRank生成文章摘要"></a>TextRank生成文章摘要</h3><p>　　将文本中的每个句子分别看做一个节点，如果两个句子有相似性，那么认为这两个句子对应的节点之间存在一条无向有权边。考察句子相似度的方法是下面这个公式：</p>
<p><img src="https://img-blog.csdnimg.cn/20181104103726372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FpYW45OQ==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>公式中，Si,Sj分别表示两个句子词的个数总数，Wk表示句子中的词，那么分子部分的意思是同时出现在两个句子中的同一个词的个数，<u>分母是对句子中词的个数求对数之和。分母这样设计可以遏制较长的句子在相似度计算上的优势。</u></p>
<p>我们可以根据以上相似度公式循环计算任意两个节点之间的相似度，根据阈值去掉两个节点之间相似度较低的边连接，构建出节点连接图，然后计算TextRank值，最后对所有TextRank值排序，选出TextRank值最高的几个节点对应的句子作为摘要。</p>
<h2 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h2><p>​    Bag of words模型，也叫做“词袋”，在信息检索中，Bag of words model假定对于一个文本，忽略其词序和语法、句法，将其仅仅看做是一个词集合，或者说是词的一个组合，文本中每个词的出现都是独立的，不依赖于其他词是否出现，或者说当这篇文章的作者在任意一个位置选择一个词汇都不受前面句子的影响而独立选择的。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>词向量</tag>
        <tag>TF-IDF</tag>
        <tag>TextRank</tag>
        <tag>PageRank</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/24/WordEmbedding2:%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li><strong>基于one-hot、tf-idf、textrank等的bag-of-words；</strong></li>
<li>==<strong>主题模型：LSA（SVD）、pLSA、LDA；</strong>==</li>
<li><strong>基于词向量的固定表征：word2vec、fastText、glove</strong></li>
<li><strong>基于词向量的动态表征：elmo、GPT、bert</strong></li>
</ul>
<h1 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h1><p>各种模型的优缺点：</p>
<ul>
<li>One-hot：维度灾难 and 语义鸿沟</li>
<li>矩阵分解（LSA）：利用全局语料特征，但SVD求解计算复杂度大</li>
<li>基于NNLM/RNNLM的词向量：词向量为副产物，存在效率不高等问题</li>
<li>word2vec、fastText：优化效率高，但是基于局部语料</li>
<li>glove：基于全局预料，结合了LSA和word2vec的优点</li>
<li>elmo、GPT、bert：动态特征</li>
</ul>
<h2 id="LSA（隐语义分析）"><a href="#LSA（隐语义分析）" class="headerlink" title="LSA（隐语义分析）"></a>LSA（隐语义分析）</h2><h3 id="SVD（奇异值分解）"><a href="#SVD（奇异值分解）" class="headerlink" title="SVD（奇异值分解）"></a>SVD（奇异值分解）</h3><p>LSA(latent semantic analysis)潜层语义分析，也被称为LSI(latent semantic index)，是Scott Deerwester, Susan T. Dumais等人在1990年提出来的一种新的索引和检索算法。该算法和传统向量空间模型(vector space model)一样使用向量来表示词(word)和文档(documents)，vsm是通过向量间的关系(如夹角)来判断词及文档间的关系，而不同的 是，LSA将词和文档映射到潜在语义空间，从而去除了原始向量空间中的一些“噪音”，提高了信息检索的精确度。我们下面就先从推荐系统的角度简单的解释一下，什么是浅语意空间。</p>
<p>这里简单的根据推荐系统来说，这里使用给用户推荐电影的例子来解释，首先我们会得到一个评分矩阵，这个矩阵呢它的行是item（主题），如果推荐的是电影的话，那么item就是电影名了，而列就是用户了即user，我们从不同的用户中就可以得到这样的评分矩阵，如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20181219094042449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>现在的问题是，1、这个评分矩阵很大。2、这个矩阵是稀疏，什么意思呢？假如这个矩阵是给电影评分的，那么我们不能得到所有用户给所有的电影评分，因此这个矩阵中会有很多的空缺值。因此推荐系统中会有这两个问题的存在，如何解决呢？这里使用的是SVD 进行解决，我们看看他是如何解决推荐系统的两个问题的，其实很简单，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/2018121910050073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>假如我们的评分矩阵是nxm的矩阵，其中m代表user，n代表item，我们可以通过两个矩阵的相乘的形式得到评分矩阵，写成上图等号右边的形式。</p>
<p>上图我们可看到评分矩阵可以通过nxk的矩阵和kxm的矩阵相乘得到，这里的k是隐分类的意思，<u>这里的隐分类不是我们人为划分的，一般都是我们通过矩阵分解以后得到这个k，</u>然后通过两个矩阵的内容进行判断隐分类的含义。</p>
<p>这里以电影评分矩阵进行比喻，一旦通过矩阵分解成上面的形式，我就可以得到电影评分的矩阵分解了，就会得到隐分类了，此时我们观察分解后的矩阵就会发现，隐分类代表的是某一类型电影，如上图等号右边的第一个矩阵即nxk矩阵，就是说对这n个电影给出概率或者打分来说明他是属于电影的哪一类如科幻、爱情、恐怖等等，此时的k就是代表电影的类型了也就是隐分类了，根据每部电影的行中不同的值来判断它属于那个电影类型的概率，这就是上图等号右边第一个矩阵的含义，那么等号右边的后面的那个矩阵代表什么呢？其实很类似的分析，每个用户代表着一列，那么每行代表在不同类型的电影，我们通过分析用户观看哪种类型的电影概率或者评分最高，以此来给用户推荐他喜欢的类型电影。</p>
<p>由此我们可以发现在电影的评分中隐分类就代表着电影的类型，而分解后的两个矩阵对我们都很有用，这就是我们k的物理意义和分解后矩阵代表的含义，但是我们还没解释他是如何解决推荐系统的两个问题的，下面我们就来解释一下：假如我们分解后的矩阵的k值通常要比n和m小的多数值，如n=100万部电影，k=100种类型，m=100万人，我们来计算一下分解后的数据有多少个：nxk+kxm = 100万x100 + 100x100万 = 2亿个数据，需要2亿个存储单元，我们看看原始评分矩阵的大小：nxm= 100万x100万=10000亿，可想而知，存储量很大，因此矩阵分解可以起到降维、压缩数据的作用。因为数据压缩了其实就解决了稀疏性的问题，稍后大家会看到如何解决的，上面就是推荐系统的应用，那么在文本分类是如何使用的呢？</p>
<h3 id="LSA用于文本分类"><a href="#LSA用于文本分类" class="headerlink" title="LSA用于文本分类"></a>LSA用于文本分类</h3><img src="https://img-blog.csdnimg.cn/20181219105441296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

<p>每篇文章我们都可以构造一个词向量，这样由多篇文章就可以构成一个矩阵，如上图的等号左边的图，这里的m就是文章数了，n就是每个词袋的元素数了，通过矩阵分解后就会得到像上图等号右边的第一个矩阵形式，和推荐系统类似，这里的k代表的就是隐分类，他的物理意义就是说在每个词向量（文本）的元素中概率或者评分相近的词，就是同义词和近义词了，那么第二个矩阵就相当于降维了，即我们关键的信息留下来，同义词和近义词我们按照左边的分解取一个概率最大的表示，如我们讨论两个文本是否相似时，我们知道评分矩阵的维度是很大，而且还是稀疏的，但是我们通过矩阵分解以后就会得到隐特征，即主要的信息都保存下来了，此时我们的矩阵就不在是稀疏了，这也就解释了为什么起到降维和解决稀疏矩阵的原理了。</p>
<p>这里大家不应太纠结隐分类到底代表什么，我们不需要知道，只需要判断即可，这就是SVD用在文本分类中的原理，因为文本分类是最早使用SVD的，因此，推荐系统是借鉴了文本分类的应用才研究出推荐系统的，这里就不在过多讨论了，大家肯定想知道，这个矩阵分解到底是如何做呢？怎么得到这个k的值呢？如何确定呢？是人为确定还是自动生成呢？我们的主要精力就来看看SVD到底是如何分解的。答：奇异值矩阵分解。</p>
<h2 id="PLSA（基于概率的隐语意分析）"><a href="#PLSA（基于概率的隐语意分析）" class="headerlink" title="PLSA（基于概率的隐语意分析）"></a>PLSA（基于概率的隐语意分析）</h2><img src="https://img-blog.csdnimg.cn/20181219105441296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />



<p>我们通过矩阵的分解对文本数据进行压缩，压缩量很可观，尤其是原始的矩阵的维度很高时压缩的更可观，因为k通常要远远小于n。</p>
<p>如上图等号左边的矩阵其实就是我们的文本的词向量组成的，我们知道一篇文章的词是很多的，而且还是稀疏的，如果一旦文章数也很多,那么整个矩阵的元素会很大很大，但是通过矩阵分解就会减少很多。上图中的每一列都代表一个文本的词向量，里面的值是词向量的权值，那么我们分解后的矩阵分别代表什么呢？其中k就是隐分类或者说是隐特征，如果多个词在同一列出现就说明这几个词是相近的，在最右边的矩阵是什么意思呢？可以理解为经过压缩后的文本特征，每个文本都有k个特征，然后对比一下，以此来判断是否相似。</p>
<p>还有一种用法就是我先通过矩阵分解，然后在组合成nxm的矩阵，这个新组合的矩阵和原始矩阵很像，但是肯定不一样，因为我们中间在特征值时略去了部分特征值，怎么理解这一步呢？大家可以理解为我们是==去除噪声==，留下的才是主要特征，和PCA技术差不多。但是这个方法就没有缺点吗？有的，下面我们来看看：</p>
<p>缺点是SVD的分解的计算量太大，计算复杂度高，当矩阵达到1000维以上时计算已经非常缓慢，但文本分析一般都会形成非常大型的“文档-词”矩阵，从而难以实现，甚至存储都很困难。因此需要引入新的求解SVD的方法，这时一种新型的求解思路就出来了，下面还以推荐系统的电影分类为例进行讲解：</p>
<img src="https://img-blog.csdnimg.cn/2018121910050073.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:67%;" />

<p>按照我们上一节的内容就是当得到评分矩阵时，就可以直接对其进行分解，但是问题是当这个评分矩阵的维度很大时，SVD的计算量将很大，为了避免这么大的计算量，我们采用这样的做法，就是我把上图的等号右边的两个矩阵的元素全看做 变量，对，你没看错，全看做变量，那么我让他们相乘就会得到和原始评分矩阵维度一样的矩阵，那么这个时候我把原始矩阵已知的值和计算出来的矩阵相对应位置的值尽量相等，这样就建立了优化函数，然后使用优化算法使其误差达到最低，一旦我们合成的矩阵符合我们的要求，同时就可推测原始评分稀疏矩阵的值了，通过预测的值的大小就可以推荐给用户分值高的电影了，下面结合图来讲：</p>
<img src="https://img-blog.csdnimg.cn/2018121919005668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5ODY1OA==,size_16,color_FFFFFF,t_70" alt="img" style="zoom: 67%;" />

<p>首先我们构建两个矩阵维度为nxk和kxm的，如上图的中间部分，那么我把这两个矩阵的元素都看做变量，这时候把矩阵相乘得到合成评分矩阵B，如上图的右端，那么把合成的数据和原始的评分矩阵A对应的位置相比较如上图的A蓝色点，黄色点是缺少的（意思是用户没有看过该影片），使他们尽量的接近，怎么衡量呢？误差平方和函数呀，因此可以得到关于很多变量的误差函数L，此时我们使用优化算法进行优化，一旦达到我们的要求，那么说明我们的分解矩阵就确定了，此时使用这个 再去预测A矩阵的位置的黄色的点，这可以对评分矩阵的稀缺值进行填充，进而根据分值大小给用户推荐电影了，就是这个原理。这样就巧妙的避免了求解SVD了，一旦得到优化函数，我们就可以通过梯度下降得到我们的极值。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>词向量</tag>
        <tag>LSA</tag>
        <tag>SVD</tag>
        <tag>pLSA</tag>
        <tag>LDA</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/10/24/WordEmbedding3:%E5%9F%BA%E4%BA%8E%E8%AF%8D%E5%90%91%E9%87%8F%E7%9A%84%E5%9B%BA%E5%AE%9A%E8%A1%A8%E5%BE%81/</url>
    <content><![CDATA[<h1 id="基于词向量的固定表征"><a href="#基于词向量的固定表征" class="headerlink" title="基于词向量的固定表征"></a>基于词向量的固定表征</h1><h2 id="GloVe"><a href="#GloVe" class="headerlink" title="GloVe"></a>GloVe</h2>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>词向量</tag>
        <tag>GloVe，Word2Vector</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2021/06/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h3 id="数塔问题"><a href="#数塔问题" class="headerlink" title="数塔问题"></a><center>数塔问题</center></h3><p>当前的位置一定要走，从左OR从右</p>
<h3 id="最长不下降子序列LIS"><a href="#最长不下降子序列LIS" class="headerlink" title="最长不下降子序列LIS"></a><center>最长不下降子序列LIS</center></h3><p>当前这个数一定要选，接着第一个OR第二个…当前的前一个数构成</p>
<h3 id="最长公共子序列LCS"><a href="#最长公共子序列LCS" class="headerlink" title="最长公共子序列LCS"></a><center>最长公共子序列LCS</center></h3><p>截止到当前这两个，如果相同则+1OR不同，去找前面最大的状态继承。也就是dp数组含义为截止到目前两个位置的最长公共子序列长度</p>
<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a><center>最大子序和</center></h3><p>输入：nums = [-2,1,-3,4,-1,2,1,-5,4] </p>
<p>输出：6 </p>
<p>解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</p>
<p>思路：dp[i]代表以i结束的最大子序列和，对于每个当前的i，都是必选的。要么选择前面的加和，要么不选。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">30000</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;numsSize;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=(dp[i<span class="number">-1</span>]+nums[i]&gt;nums[i]?(dp[i<span class="number">-1</span>]+nums[i]):nums[i]);</span><br><span class="line">        max=(dp[i]&gt;max?dp[i]:max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a><center>最长回文子串</center></h3><p>输入：s = “babad” </p>
<p>输出：”bab” </p>
<p>解释：”aba” 同样是符合题意的答案。</p>
<p>思路：搜索边界是长度为1的字符串，搜索方式是按照字符串长度的递增进行搜索。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">longestPalindrome</span><span class="params">(<span class="keyword">char</span> * s)</span></span>&#123;</span><br><span class="line"><span class="comment">//分析：动态规划中的边界，就是当只有一个字母时，肯定是回文。</span></span><br><span class="line"><span class="comment">//第二种边界就是有两个连续一样的字母，是回文</span></span><br><span class="line"><span class="comment">//针对这两点可以分开来，用if else 语句分别来判断</span></span><br><span class="line"><span class="keyword">int</span> length =(<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">if</span>(length==<span class="number">0</span>||length==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> table[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line"> table[i][i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>;<span class="keyword">int</span> len=<span class="number">1</span>;<span class="comment">//字符开始的位置和长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length;j++)<span class="comment">//方向采用的是自上而下</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)<span class="comment">//这个有一个，两个，三个，字母的时候，根本不用看里面，只要s[i]==s[j]就行</span></span><br><span class="line">            &#123;</span><br><span class="line">                table[i][j]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               table[i][j]=table[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        table[i][j]=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(table[i][j]&amp;&amp;(j-i+<span class="number">1</span>)&gt;len)</span><br><span class="line">        &#123;</span><br><span class="line">            start = i;</span><br><span class="line">            len =j-i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s[start+len]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>(s+start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="不同路径个数"><a href="#不同路径个数" class="headerlink" title="不同路径个数"></a><center>不同路径个数</center></h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。  问总共有多少条不同的路?</p>
<p><img src="https://i.loli.net/2021/06/15/WX6FYAVml8seMCE.png" alt="robot_maze.png"></p>
<p>思路：边界，搜索方式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[m][n];</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * m * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h3><p>思路：第一行和第一列作为动归边界，按照左上到右下的顺序进行动归。</p>
<p><img src="https://i.loli.net/2021/06/15/PzLs1XGA9dqU5bS.jpg" alt="minpath.jpg"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width = grid[<span class="number">0</span>].length, high = grid.length;</span><br><span class="line">        <span class="keyword">if</span> (high == <span class="number">0</span> || width == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; high; i++) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; width; i++) grid[<span class="number">0</span>][i] += grid[<span class="number">0</span>][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; high; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; width; j++)</span><br><span class="line">                grid[i][j] += Math.<span class="built_in">min</span>(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> grid[high - <span class="number">1</span>][width - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉搜索树的个数"><a href="#二叉搜索树的个数" class="headerlink" title="二叉搜索树的个数"></a>二叉搜索树的个数</h3><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p>
<p>输入: 3 </p>
<p>输出: 5 </p>
<p>解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:    </p>
<p><img src="https://i.loli.net/2021/06/15/31jVGqlQrvu5aDp.png" alt="image.png">             </p>
<p>思路：每个大型二叉树的左右子树分别是两颗小型二叉树</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">1000</span>];   <span class="comment">//dp[i]是以1...i的二叉搜索树个数</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]+=dp[j<span class="number">-1</span>]*dp[i-j]; <span class="comment">//以某个数为顶，看左右为几个数组成的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子序列判断"><a href="#子序列判断" class="headerlink" title="子序列判断"></a>子序列判断</h3><p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。  字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">int</span> m = t.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];<span class="comment">//dp[i][j]：表示字符串 t 的前 i 个元素和字符串 s 的前 j 个元素中公共子序列的长度。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="built_in">t</span>(j - <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[m][n] == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/06/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>朴素贝叶斯</title>
    <url>/2021/10/24/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/</url>
    <content><![CDATA[<h1 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h1><p>在所有的机器学习分类算法中，朴素贝叶斯和其他绝大多数的分类算法都不同。对于大多数的分类算法，比如决策树,KNN,逻辑回归，支持向量机等，他们都是判别方法，也就是直接学习出特征输出Y和特征X之间的关系，要么是决策函数𝑌=𝑓(𝑋)Y=f(X),要么是条件分布𝑃(𝑌|𝑋)P(Y|X)。但是朴素贝叶斯却是==生成方法==，也就是直接找出特征输出Y和特征X的联合分布𝑃(𝑋,𝑌)P(X,Y),然后用𝑃(𝑌|𝑋)=𝑃(𝑋,𝑌)/𝑃(𝑋)P(Y|X)=P(X,Y)/P(X)得出。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>贝叶斯公式是**==“执果索因”==**：发生了结果，那么哪个原因可能性大？</p>
<img src="https://pic2.zhimg.com/80/v2-5ea21d9dcaeb14a5a163324b271e05a9_1440w.jpg" alt="img" style="zoom: 50%;" />

<p>举个简单的例子：村子有且仅有两个小偷，小A和小B，根据统计A偷东西的可能性是0.2,B偷东西的可能性是0.8。如果A去偷，偷成功的概率是0.8， 如果B去偷，偷成功的概率是0.3。如果村子丢了一件东西，A和B谁是嫌疑犯的可能性更大？</p>
<p>H={丢东西}</p>
<p>A = {A去偷东西}</p>
<p>B = {B去偷东西}</p>
<p>P(A) + P(B) = 1</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqhzcij90j611c0n4jut02.jpg" alt="image-20211024155658056" style="zoom:50%;" />



<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqhzd1ys1j60pk040q3602.jpg" alt="image-20211024163655561" style="zoom:50%;" />，然后假设各个维度的x相互独立，这样方便计算。</p>
<p>现在发生了$x^{test}$，是那种$C^k$种类产生的概率比较大？先验+数据（似然），求后验概率，过程如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqhzdu5coj615y0j60v002.jpg" alt="image-20211024163838725"></p>
<p>为了计算还会假设离散的样本符合伯努利分布，连续值符合正态分布。</p>
<p>原文：<a href="https://www.cnblogs.com/pinard/p/6069267.html">https://www.cnblogs.com/pinard/p/6069267.html</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>朴素贝叶斯</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/05/31/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<img src="https://i.loli.net/2021/07/28/9j2c8MsQCd7GhqW.png" alt="image.png" style="zoom:80%;" />

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://i.loli.net/2021/07/28/58muPeCEJsRXvao.gif" alt="v2-62b35f38b9806cb2e50c7e4ee0ec3386_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;</span><br><span class="line">        <span class="built_in">swap</span>(A[j<span class="number">-1</span>],A[j]);</span><br><span class="line">        flag=<span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="选择排序法"><a href="#选择排序法" class="headerlink" title="选择排序法"></a>选择排序法</h2><p><img src="https://i.loli.net/2021/07/28/rxCE7jPqwzkJsvi.gif" alt="v2-c5e176ffc200c8f4f137e732fe860b60_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">    min=i;</span><br><span class="line">    <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">      <span class="keyword">if</span>(A[j]&lt;A[min]) min=j;</span><br><span class="line">    <span class="keyword">if</span>(min!=i) </span><br><span class="line">      <span class="built_in">swap</span>(A[i],A[min]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="插入排序法"><a href="#插入排序法" class="headerlink" title="插入排序法"></a>插入排序法</h2><p><img src="https://i.loli.net/2021/07/28/9k8UFYowPH4Q2jD.gif" alt="v2-38d6f9c006e3fdb24ffd82a58c39ca92_720w.gif"></p>
<h3 id="直接插入法"><a href="#直接插入法" class="headerlink" title="直接插入法"></a>直接插入法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;	</span><br><span class="line">  <span class="keyword">int</span> i,j;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)&#123;</span><br><span class="line">      A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">    &#125;</span><br><span class="line">    A[j+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半插入法"><a href="#折半插入法" class="headerlink" title="折半插入法"></a>折半插入法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[i];</span><br><span class="line">    low=<span class="number">1</span>;high=i<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">      mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>]) high=mid<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">else</span> low=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">      A[j+<span class="number">1</span>]=A[j];</span><br><span class="line">    A[high+<span class="number">1</span>]=A[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="希尔排序法-缩小增量排序"><a href="#希尔排序法-缩小增量排序" class="headerlink" title="希尔排序法/缩小增量排序"></a>希尔排序法/缩小增量排序</h2><p><img src="https://i.loli.net/2021/07/28/avz8JiowZNMb6Ck.gif" alt="v2-924c253a0ce18b65eb5d590699c8773b_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(dk=n/<span class="number">2</span>;dk&gt;=<span class="number">1</span>;dk/=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(i=dk+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">      <span class="keyword">if</span>(A[i]&lt;A[i-dk])&#123;</span><br><span class="line">        A[<span class="number">0</span>]=A[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i-dk;j&gt;<span class="number">0</span>&amp;&amp;A[<span class="number">0</span>]&lt;A[j];j-=dk)</span><br><span class="line">          A[j+dk]=A[j];</span><br><span class="line">        A[j+dk]=A[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="https://i.loli.net/2021/07/28/OgrIWpRxiEhLzP2.gif" alt="v2-ed06651ca489ff4454e9889ca0d753db_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ElemType *B=(ElemType *)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(ElemType));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)</span><br><span class="line">    B[k]=A[k];</span><br><span class="line">  <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">      A[k]=B[i++];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      A[k]=B[j++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;=mid) A[k++]=B[i++];</span><br><span class="line">  <span class="keyword">while</span>(j&lt;=high) A[k++]=B[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSort</span>(A,low,mid);</span><br><span class="line">    <span class="built_in">MergeSort</span>(A,mid+<span class="number">1.</span>high);</span><br><span class="line">    <span class="built_in">Merge</span>(A,low,mid,high);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速排序法"><a href="#快速排序法" class="headerlink" title="快速排序法"></a>快速排序法</h2><p><img src="https://i.loli.net/2021/07/28/EiQ9IC1hTcsSdOX.gif" alt="v2-e30a1dcb54af5e222243d8053d3a5a0d_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotpos=<span class="built_in">Partition</span>(A,low,high);</span><br><span class="line">    <span class="built_in">QuickSort</span>(A,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">QuickSort</span>(A,pivot+<span class="number">1</span>,high);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">  ElemType pivot=A[low];</span><br><span class="line">  <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high&amp;&amp;A[high]&gt;=pivot) --high;</span><br><span class="line">    A[low]=A[high];</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high&amp;&amp;A[low]&lt;=pivot) ++low;</span><br><span class="line">    A[high]=A[low];</span><br><span class="line">  &#125;</span><br><span class="line">  A[low]=pivot;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><img src="https://i.loli.net/2021/07/28/vS56eJ8OxuBEwhN.gif" alt="v2-c892078dcb61230c6233fc5de4b4aebc_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(ElemType A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    <span class="built_in">HeadAdjust</span>(A,i,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(ElemType A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  A[<span class="number">0</span>]=A[k];</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">2</span>*k;i&lt;=len;i*=<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">      i++;</span><br><span class="line">    <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;A[i]) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      A[k]=A[i];</span><br><span class="line">      k=i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  A[k]=A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(Elemtype A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">  <span class="built_in">BuildMaxHeap</span>(A,len);</span><br><span class="line">  <span class="keyword">for</span>(i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">    <span class="built_in">Swap</span>(A[i],A[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">HeadAdjust</span>(A,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><img src="https://i.loli.net/2021/07/28/HE2DU8sf5Z1WOLg.gif" alt="v2-86055f604a687cc18e781160bcc8b781_720w.gif"></p>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="https://i.loli.net/2021/07/28/liCLHKy2Tgoc8aG.gif" alt="v2-ab04919ee2dbadd84ad065760b8eb1c9_720w.gif"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> exp = <span class="number">1</span>;	<span class="comment">//exp表示排到第几位了</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">buf</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (maxVal &gt;= exp) &#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> digit = (nums[i] / exp) % <span class="number">10</span>;</span><br><span class="line">    cnt[digit]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    cnt[i] += cnt[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;	<span class="comment">//注意是反着来恢复连接的</span></span><br><span class="line">    <span class="keyword">int</span> digit = (nums[i] / exp) % <span class="number">10</span>;</span><br><span class="line">    buf[cnt[digit] - <span class="number">1</span>] = nums[i];</span><br><span class="line">    cnt[digit]--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">copy</span>(buf.<span class="built_in">begin</span>(), buf.<span class="built_in">end</span>(), nums.<span class="built_in">begin</span>());</span><br><span class="line">  exp *= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><img src="https://i.loli.net/2021/07/28/gcZVTyI7Uu2w35x.gif" alt="v2-126c359bd98e64c79a2a1db2e829e57b_720w.gif" style="zoom:100%;" />

]]></content>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/06/01/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题属于动态规划，是一种对于每个元素存在两种状态（拿与不拿）的特殊动态规划问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>逆向枚举：逆向是保证当前物品只被装入背包一次</p>
<p>正向枚举：正向枚举则当前物品多次装入背包</p>
</li>
<li><p>初始状态的设计</p>
<p>* </p>
</li>
</ul>
<h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p>最基本的背包问题就是01背包问题（01 knapsack problem）：一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<p>如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的目标是书包内物品的总价值，而变量是物品和书包的限重，所以我们可定义状态dp:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j]表示将前i件物品装进限重为j的背包可以获得的最大价值, 0&lt;=i&lt;=N, 0&lt;=j&lt;=W</span><br></pre></td></tr></table></figure>
</blockquote>
<p>那么我们可以将d[0][0…W]初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。那么当 i &gt; 0 时<code>dp[i][j]</code>有两种情况：</p>
<ol>
<li>不装入第i件物品，即<code>dp[i−1][j]</code>；</li>
<li>装入第i件物品（前提是能装下），即<code>dp[i−1][j−w[i]] + v[i]</code>。</li>
</ol>
<p>即状态转移方程为</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i]) // j &gt;= w[i]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>由上述状态转移方程可知，<code>dp[i][j]</code>的值只与<code>dp[i-1][0,...,j-1]</code>有关，所以我们可以采用动态规划常用的方法（滚动数组）对空间进行优化（即去掉dp的第一维）。需要注意的是，<strong>为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖，循环的时候 j 只能逆向枚举（正向会出现同一个物品被多次放入背包的情况，空间优化前没有这个限制）</strong>，伪代码为：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 01背包问题伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        dp[j] = max(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<p>完全背包本质就是0k背包。</p>
<h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><blockquote>
<p>ks(i,t) = max{ks(i-1, t - V[i] * k) + P[i] * k};  （0 &lt;= k * V[i] &lt;= t） ks(0,t)=0;  ks(i,0)=0;</p>
</blockquote>
<p>这种思路需要枚举每一个容量下的物品数量，优点是思考简单。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 完全背包问题伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        for k = [0, 1,..., j/w[i]]</span><br><span class="line">            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>和01背包问题类似，也可进行空间优化，优化后不同点在于这里的 j 只能<strong>正向枚举（相当于一个物品重复使用了多次）</strong>而01背包只能逆向枚举，因为这里的max第二项是<code>dp[i]</code>而01背包是<code>dp[i-1]</code>，即这里就是需要覆盖而01背包需要避免覆盖。所以伪代码如下：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 完全背包问题思路一伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = w[i],...,W // 必须正向枚举!!!</span><br><span class="line">        dp[j] = max(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>多重背包（bounded knapsack problem）与前面不同就是每种物品是有限个：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p>
<p>多重背包本质就是0k背包。</p>
<p>此时的分析和完全背包思路一差不多，也是从装入第 i 种物品多少件出发：装入第i种物品0件、1件、…n[i]件（还要满足不超过限重）。所以状态方程为：</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i])</span><br><span class="line">dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>同理也可以进行空间优化，而且 j 也必须<strong>逆向枚举</strong>，优化后伪代码为</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 完全背包问题思路二伪代码(空间优化版)</span><br><span class="line">dp[0,...,W] = 0</span><br><span class="line">for i = 1,...,N</span><br><span class="line">    for j = W,...,w[i] // 必须逆向枚举!!!</span><br><span class="line">        for k = [0, 1,..., min(n[i], j/w[i])]</span><br><span class="line">            dp[j] = max(dp[j], dp[j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="恰好装满"><a href="#恰好装满" class="headerlink" title="恰好装满"></a>恰好装满</h2><p>恰好装满一开始将容量为0的dp[]初始化为0，其他初始化为-inf</p>
<p>常规背包则一开始都初始化为0</p>
<h2 id="求方案总数"><a href="#求方案总数" class="headerlink" title="求方案总数"></a>求方案总数</h2><p>将max函数换为sum函数</p>
<h2 id="求二维背包"><a href="#求二维背包" class="headerlink" title="求二维背包"></a>求二维背包</h2><p>多一层循环，其他无差别</p>
<h2 id="求最优方案"><a href="#求最优方案" class="headerlink" title="求最优方案"></a>求最优方案</h2><p>一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由哪一个策略推出来的，这样便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。</p>
<p>以01背包为例，我们可以再用一个数组G[i][j]来记录方案，设 <code>G[i][j] = 0</code>表示计算 dp[i][j] 的值时是采用了max中的前一项(也即dp[i−1][j])，<code>G[i][j] = 1</code> 表示采用了方程的后一项。即分别表示了两种策略: 未装入第 i 个物品及装了第 i 个物品。其实我们也可以直接从求好的dp[i][j]反推方案：若 <code>dp[i][j] = dp[i−1][j]</code> 说明未选第i个物品，反之说明选了。</p>
<h2 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h2><h4 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4><p>难度：太水辣</p>
<p>思路：构造一个二分之一数组和的背包，相当于“恰好填满”类背包问题。</p>
<h4 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4><p>难度：水</p>
<p>思路：除了最好想的dfs，此题还可以用背包的思想来解决。</p>
<img src="https://i.loli.net/2021/06/19/Wa3o5YEAfFRze7U.png" alt="image.png" style="zoom:50%;" />

<h4 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h4><p>难度：水</p>
<p>思路：二维背包，基础题</p>
<h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h4><p>难度：水</p>
<p>思路：完全背包，基础题，注意<strong>正向枚举</strong></p>
<h4 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h4><p>难度：水</p>
<p>思路：完全背包，基础题，注意初始化</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
</search>
